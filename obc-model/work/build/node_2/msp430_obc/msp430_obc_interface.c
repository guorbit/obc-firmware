/* File generated by kazoo for TASTE - do not edit */
#include "msp430_obc_interface.h"
#include <msp430.h>
#include <string.h>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "transport.h"


#include "hal_vm_if.h"


void pro_HAL_blink_led(void)
{
    extern SemaphoreHandle_t hal_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(hal_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    hal_blink_led();

    xSemaphoreGive(hal_Semaphore);
}
#include "loc_provider_vm_if.h"


// Required interfaces of function state_handler_entrypoint

// Required interface collect_tm in function state_handler_entrypoint
#include "tm_collection_vm_if.h"  // Remote language: C
void vm_state_handler_entrypoint_collect_tm(void)
{
   // Unprotected call (call function defined in vm_if or SIMULINK.Simulink.c function)
   tm_collection_collect_tm();
}
// Required interface request_loc in function state_handler_entrypoint
#include "loc_provider_vm_if.h"  // Remote language: C
void vm_state_handler_entrypoint_request_loc
        (char *OUT_buf_lfp, size_t *size_OUT_buf_lfp)

{
   // Unprotected call (call function defined in vm_if or SIMULINK.Simulink.c function)
   loc_provider_request_loc
        (OUT_buf_lfp, size_OUT_buf_lfp);

}
// Required interface request_tc in function state_handler_entrypoint
#include "tc_provider_vm_if.h"  // Remote language: C
void vm_state_handler_entrypoint_request_tc
        (char *OUT_buf_mcp, size_t *size_OUT_buf_mcp)

{
   // Unprotected call (call function defined in vm_if or SIMULINK.Simulink.c function)
   tc_provider_request_tc
        (OUT_buf_mcp, size_OUT_buf_mcp);

}
// Required interface send_tm_aoi in function state_handler_entrypoint
void vm_state_handler_entrypoint_send_tm_aoi
        (const char *IN_buf_lfp, size_t size_IN_buf_lfp)

{
    struct Request request;
    if(size_IN_buf_lfp != 0)
    {
        request.m_length = size_IN_buf_lfp;
        memcpy(request.m_data, IN_buf_lfp, size_IN_buf_lfp);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_gui_send_tm_aoi(&request);
}
// Required interface send_tm_mcp in function state_handler_entrypoint
void vm_state_handler_entrypoint_send_tm_mcp
        (const char *IN_buf_mcp, size_t size_IN_buf_mcp)

{
    struct Request request;
    if(size_IN_buf_mcp != 0)
    {
        request.m_length = size_IN_buf_mcp;
        memcpy(request.m_data, IN_buf_mcp, size_IN_buf_mcp);
    }
    else
    {
        request.m_length = 0;
    }
    deliver_to_gui_send_tm_mcp(&request);
}
#include "state_handler_entrypoint_vm_if.h"


void pro_state_handler_entrypoint_poll_aoi(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_poll_aoi();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
void pro_state_handler_entrypoint_poll_mcp(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_poll_mcp();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
void pro_state_handler_entrypoint_toggle_pwr(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_toggle_pwr();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
void pro_state_handler_entrypoint_trig_aoi(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_aoi();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
void pro_state_handler_entrypoint_trig_mcp(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_mcp();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
void pro_state_handler_entrypoint_trig_pwr(void)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_pwr();

    xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "tc_provider_vm_if.h"


#include "tm_collection_vm_if.h"




#include "hal_vm_if.h"

void call_hal_blink_led (const char* buf, size_t len)
{
    hal_blink_led();
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_poll_aoi (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_poll_aoi();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_poll_mcp (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_poll_mcp();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_toggle_pwr (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_toggle_pwr();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_trig_aoi (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_aoi();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_trig_mcp (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_mcp();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
#include "state_handler_entrypoint_vm_if.h"

void call_state_handler_entrypoint_trig_pwr (const char* buf, size_t len)
{
    extern SemaphoreHandle_t state_handler_entrypoint_Semaphore;

    BaseType_t result;
    do
    {
        result = xSemaphoreTake(state_handler_entrypoint_Semaphore, portMAX_DELAY);
    } while(result != pdTRUE);

    state_handler_entrypoint_trig_pwr();
	xSemaphoreGive(state_handler_entrypoint_Semaphore);
}
