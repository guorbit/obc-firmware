/* Body file for function HAL
 * Generated by TASTE (kazoo/templates/skeletons/c-body/function.tmplt)
 * You can edit this file, it will not be overwritten

    !! IMPORTANT                                                        !!
    !! When you modify your design (interface view), you must update    !!
    !! the procedures corresponding to the provided interfaces in this  !!
    !! file. The up-to-date signatures can be found in the header file. !!
*/

#include "hal.h"

#include <msp430.h>
#include <FreeRTOS.h>
#include <semphr.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "msp430_i2c.h"

#define pipeline_i2c_read_buffer_length 2
bool pipeline_i2c_read_successful = false;
unsigned char pipeline_i2c_read_buffer[pipeline_i2c_read_buffer_length];


void hal_startup( void )
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    WDTCTL = WDTPW | WDTHOLD;           // stop watchdog timer
    PM5CTL0 &= ~LOCKLPM5;               // disable the GPIO power-on default high-impedance mode
                                        // to activate previously configured port settings

    P1DIR |= BIT0 | BIT3 | BIT4 | BIT5; // Set P1.0, 1.3, 1.4, 1.5 to output direction
    P4DIR |= BIT6;                      // Set P4.6 to output direction
    P4OUT &= ~BIT6;                     // Unset P4.6

    msp430_i2c_init();
}

void hal_PI_blink_led(void)
{
    P1OUT ^= BIT0;                      // Toggle P1.0 using XOR
}

void hal_PI_set_led( const asn1SccT_Boolean *IN_val )
{
    if (*IN_val)
    {
        P4OUT |= BIT6;                  // Set P4.6 using OR
    }
    else
    {
        P4OUT &= ~BIT6;                 // Unset P4.6 using AND
    }
}

void hal_PI_send_camera_idle_signal()
{
    P1OUT ^= BIT3;
}

void hal_PI_send_camera_capture_image_pulse()
{
    P1OUT ^= BIT4;
}

void hal_PI_send_camera_toggle_usb_pulse()
{
    P1OUT ^= BIT5;
}

void hal_PI_change_pipeline_mode( const asn1SccPipeline_Mode_T *IN_target_pipeline_mode )
{
    P1OUT ^= BIT0;
    if (*IN_target_pipeline_mode == asn1SccPipeline_Mode_T_pipeline_idle)
    {
        msp430_i2c_write_data(8, 'i', " ", 1);
    }
    else
    {
        msp430_i2c_write_data(8, 'p', " ", 1);
    }
    P1OUT ^= BIT0;

    pipeline_i2c_read_successful = msp430_i2c_read_data(8, 0x10, pipeline_i2c_read_buffer, pipeline_i2c_read_buffer_length);
}

void hal_PI_check_pipeline_response_i2c()
{
    asn1SccPipeline_Mode_Status_Report_T *OUT_pipeline_report;

    if (pipeline_i2c_read_successful)
    {
        if (pipeline_i2c_read_buffer[0] == 'i')
        {
            OUT_pipeline_report->pipeline_mode = asn1SccPipeline_Mode_T_pipeline_idle;
        }
        else if (pipeline_i2c_read_buffer[0] == 'p')
        {
            OUT_pipeline_report->pipeline_mode = asn1SccPipeline_Mode_T_pipeline_processing_lp;
        }

        if (pipeline_i2c_read_buffer[1] == 't')
        {
            OUT_pipeline_report->pipeline_last_op = asn1SccMode_Status_Operation_T_mode_status_change;
        }
        else if (pipeline_i2c_read_buffer[1] == 'f')
        {
            OUT_pipeline_report->pipeline_last_op = asn1SccMode_Status_Operation_T_mode_status_change;
        }

        hal_RI_report_pipeline_mode_status(OUT_pipeline_report);
        pipeline_i2c_read_successful = false;
    }
}
