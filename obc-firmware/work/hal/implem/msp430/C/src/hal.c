/* Body file for function HAL
 * Generated by TASTE on 2023-03-10 23:20:06
 * You can edit this file, it will not be overwritten
 * Provided interfaces : get_temperature, led_blink
 * Required interfaces : 
 * User-defined properties for this function:
 *   |_ Taste::Startup_Priority = 1
 * Timers              : 
 */

#include "hal.h"

#include <msp430.h>
#include <FreeRTOS.h>
#include <semphr.h>

#include <stdlib.h>
#include <string.h>

#include "msp430_uart.h"

bool P4_6_LED_ON = false;

typedef struct cmdQueueNode
{
    struct cmdQueueNode* next;
    unsigned char* cmdData; // cmd code always exactly of size 2
    uint8_t cmdDataSize;
} cmdQueueNode;

typedef struct cmdQueue
{
    cmdQueueNode* head;
    cmdQueueNode* tail;
    uint8_t size;
} cmdQueue;

void cmdQueueNodeFree( cmdQueueNode* node );
void cmdQueueInit( cmdQueue* queue );
void cmdQueueEnqueue( cmdQueue* queue, cmdQueueNode* node );
const cmdQueueNode* cmdQueuePeek( cmdQueue* queue );
cmdQueueNode* cmdQueueDequeue( cmdQueue* queue );
void cmdQueueAddCmd( cmdQueue* queue, const unsigned char cmd[], const unsigned char param[], const uint8_t paramSize );
void cmdQueuePopCmd( cmdQueue* queue );
void cmdQueueSendCmd( cmdQueue* queue );

void hal_startup( void )
{
   // Write your initialisation code, but DO NOT CALL REQUIRED INTERFACES
    WDTCTL = WDTPW | WDTHOLD;           // stop watchdog timer
    PM5CTL0 &= ~LOCKLPM5;               // disable the GPIO power-on default high-impedance mode
                                        // to activate previously configured port settings

    P1DIR |= 0x01;                      // Set P1.0 to output direction
    P4DIR |= 0x40;                      // Set P4.6 to output direction
    P4OUT &= ~0x40;                     // Unset P4.6
    USART0_Init();
}

void hal_PI_blink_led(void)
{
   // Write your code here
    P1OUT ^= 0x01;                      // Toggle P1.0 using XOR
    USART0_SendByte('.');
}

void hal_PI_set_led( const asn1SccT_Boolean *IN_val )
{
    if (*IN_val)
    {
        P4OUT |= 0x40;                  // Set P4.6 using OR
    }
    else
    {
        P4OUT &= ~0x40;                 // Unset P4.6 using AND
    }
    P4_6_LED_ON = *IN_val;
}

void cmdQueueNodeFree( cmdQueueNode* node )
{
    free(node->cmdData);
    free(node);
}

void cmdQueueInit( cmdQueue* q )
{
    q->head = NULL;
    q->tail = NULL;
    q->size = 0;
}

void cmdQueueEnqueue( cmdQueue* queue, cmdQueueNode* node )
{
    node->next = NULL;
    if (queue->tail == NULL)
    {
        queue->head = node;
    }
    else
    {
        queue->tail->next = node;
    }
    queue->tail = node;
    queue->size++;
}

cmdQueueNode* cmdQueueDequeue( cmdQueue* queue )
{
    if (queue->head == NULL) // underflow
    {
        return NULL;
    }
    cmdQueueNode* node = queue->head;
    queue->head = queue->head->next;
    if (queue->head == NULL)
    {
        queue->tail = NULL;
    }
    queue->size--;

    return node;
}

const cmdQueueNode* cmdQueuePeek( cmdQueue* queue )
{
    return queue->head;
}

void cmdQueueAddCmd( cmdQueue* queue, const unsigned char cmd[], const unsigned char param[], const uint8_t paramSize )
{
    cmdQueueNode* newNode = (cmdQueueNode*)malloc(sizeof(cmdQueueNode));
    if (newNode != NULL)
    {
        unsigned char* cmdDataField = (unsigned char*)malloc(sizeof(unsigned char*) * (paramSize+2));
        if (cmdDataField == NULL) // not enought memory for newNode cmd data
        {
            free(newNode);
        }
        else
        {
            memcpy(newNode->cmdData, cmd, 2);
            memcpy(newNode->cmdData+2, param, paramSize);
            newNode->cmdDataSize = paramSize+2;
            cmdQueueEnqueue(queue, newNode);
        }
    }
}

void cmdQueuePopCmd( cmdQueue* queue )
{
    cmdQueueNode* popedNode = cmdQueueDequeue(queue);
    if (popedNode != NULL)
    {
        cmdQueueNodeFree(popedNode);
    }
}

void cmdQueueSendCmd( cmdQueue* queue )
{
    const cmdQueueNode* node = cmdQueuePeek(queue);
    if (node != NULL)
    {
        USART0_SendByte('~');
        USART0_SendData(node->cmdData, node->cmdDataSize, 1);
    }
}
