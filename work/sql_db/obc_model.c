/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "obc_model.h"




flag CounterK_Equal(const CounterK* pVal1, const CounterK* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag CounterK_IsConstraintValid(const CounterK* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 1000UL);
    *pErrCode = ret ? 0 :  ERR_COUNTERK; 

	return ret;
}

void CounterK_Initialize(CounterK* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag CounterK_Encode(const CounterK* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? CounterK_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag CounterK_Decode(CounterK* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_COUNTERK;

	return ret  && CounterK_IsConstraintValid(pVal, pErrCode);
}

flag CounterK_ACN_Encode(const CounterK* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? CounterK_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1000);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag CounterK_ACN_Decode(CounterK* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1000);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_COUNTERK;

    return ret && CounterK_IsConstraintValid(pVal, pErrCode);
}



flag Time_UNIX_Equal(const Time_UNIX* pVal1, const Time_UNIX* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Time_UNIX_IsConstraintValid(const Time_UNIX* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967294UL);
    *pErrCode = ret ? 0 :  ERR_TIME_UNIX; 

	return ret;
}

void Time_UNIX_Initialize(Time_UNIX* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag Time_UNIX_Encode(const Time_UNIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Time_UNIX_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967294LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Time_UNIX_Decode(Time_UNIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967294LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TIME_UNIX;

	return ret  && Time_UNIX_IsConstraintValid(pVal, pErrCode);
}

flag Time_UNIX_ACN_Encode(const Time_UNIX* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Time_UNIX_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967294LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Time_UNIX_ACN_Decode(Time_UNIX* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967294LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TIME_UNIX;

    return ret && Time_UNIX_IsConstraintValid(pVal, pErrCode);
}



flag Latitude_WGS84_Equal(const Latitude_WGS84* pVal1, const Latitude_WGS84* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Latitude_WGS84_IsConstraintValid(const Latitude_WGS84* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-9.0000000000000000000E+001 <= (*(pVal))) && ((*(pVal)) <= 9.0000000000000000000E+001));
    *pErrCode = ret ? 0 :  ERR_LATITUDE_WGS84; 

	return ret;
}

void Latitude_WGS84_Initialize(Latitude_WGS84* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag Latitude_WGS84_Encode(const Latitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Latitude_WGS84_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Latitude_WGS84_Decode(Latitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LATITUDE_WGS84;

	return ret  && Latitude_WGS84_IsConstraintValid(pVal, pErrCode);
}

flag Latitude_WGS84_ACN_Encode(const Latitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Latitude_WGS84_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Latitude_WGS84_ACN_Decode(Latitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LATITUDE_WGS84;

    return ret && Latitude_WGS84_IsConstraintValid(pVal, pErrCode);
}



flag Longitude_WGS84_Equal(const Longitude_WGS84* pVal1, const Longitude_WGS84* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Longitude_WGS84_IsConstraintValid(const Longitude_WGS84* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-1.8000000000000000000E+002 <= (*(pVal))) && ((*(pVal)) <= 1.8000000000000000000E+002));
    *pErrCode = ret ? 0 :  ERR_LONGITUDE_WGS84; 

	return ret;
}

void Longitude_WGS84_Initialize(Longitude_WGS84* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag Longitude_WGS84_Encode(const Longitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Longitude_WGS84_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Longitude_WGS84_Decode(Longitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_LONGITUDE_WGS84;

	return ret  && Longitude_WGS84_IsConstraintValid(pVal, pErrCode);
}

flag Longitude_WGS84_ACN_Encode(const Longitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Longitude_WGS84_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Longitude_WGS84_ACN_Decode(Longitude_WGS84* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_LONGITUDE_WGS84;

    return ret && Longitude_WGS84_IsConstraintValid(pVal, pErrCode);
}



flag Location_Equal(const Location* pVal1, const Location* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->lat == pVal2->lat);

    if (ret) {
        ret = (pVal1->lon == pVal2->lon);

    }

	return ret;

}

flag Location_IsConstraintValid(const Location* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Latitude_WGS84_IsConstraintValid((&(pVal->lat)), pErrCode);
    if (ret) {
        ret = Longitude_WGS84_IsConstraintValid((&(pVal->lon)), pErrCode);
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Location_Initialize(Location* pVal)
{
	(void)pVal;



	/*set lat */
	Latitude_WGS84_Initialize((&(pVal->lat)));
	/*set lon */
	Longitude_WGS84_Initialize((&(pVal->lon)));
}

flag Location_Encode(const Location* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Location_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode lat */
	    ret = Latitude_WGS84_Encode((&(pVal->lat)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lon */
	        ret = Longitude_WGS84_Encode((&(pVal->lon)), pBitStrm, pErrCode, FALSE);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Location_Decode(Location* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode lat */
	ret = Latitude_WGS84_Decode((&(pVal->lat)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lon */
	    ret = Longitude_WGS84_Decode((&(pVal->lon)), pBitStrm, pErrCode);
	}   /*COVERAGE_IGNORE*/

	return ret  && Location_IsConstraintValid(pVal, pErrCode);
}

flag Location_ACN_Encode(const Location* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Location_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode lat */
	    ret = Latitude_WGS84_ACN_Encode((&(pVal->lat)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lon */
	        ret = Longitude_WGS84_ACN_Encode((&(pVal->lon)), pBitStrm, pErrCode, FALSE);
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Location_ACN_Decode(Location* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode lat */
	ret = Latitude_WGS84_ACN_Decode((&(pVal->lat)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lon */
	    ret = Longitude_WGS84_ACN_Decode((&(pVal->lon)), pBitStrm, pErrCode);
	}   /*COVERAGE_IGNORE*/

    return ret && Location_IsConstraintValid(pVal, pErrCode);
}



flag Location_Fix_Packet_Equal(const Location_Fix_Packet* pVal1, const Location_Fix_Packet* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->t == pVal2->t);

    if (ret) {
        ret = (pVal1->lat == pVal2->lat);

        if (ret) {
            ret = (pVal1->lon == pVal2->lon);

        }

    }

	return ret;

}

flag Location_Fix_Packet_IsConstraintValid(const Location_Fix_Packet* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Time_UNIX_IsConstraintValid((&(pVal->t)), pErrCode);
    if (ret) {
        ret = Latitude_WGS84_IsConstraintValid((&(pVal->lat)), pErrCode);
        if (ret) {
            ret = Longitude_WGS84_IsConstraintValid((&(pVal->lon)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Location_Fix_Packet_Initialize(Location_Fix_Packet* pVal)
{
	(void)pVal;



	/*set t */
	Time_UNIX_Initialize((&(pVal->t)));
	/*set lat */
	Latitude_WGS84_Initialize((&(pVal->lat)));
	/*set lon */
	Longitude_WGS84_Initialize((&(pVal->lon)));
}

flag Location_Fix_Packet_Encode(const Location_Fix_Packet* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Location_Fix_Packet_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode t */
	    ret = Time_UNIX_Encode((&(pVal->t)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lat */
	        ret = Latitude_WGS84_Encode((&(pVal->lat)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode lon */
	            ret = Longitude_WGS84_Encode((&(pVal->lon)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Location_Fix_Packet_Decode(Location_Fix_Packet* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode t */
	ret = Time_UNIX_Decode((&(pVal->t)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lat */
	    ret = Latitude_WGS84_Decode((&(pVal->lat)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode lon */
	        ret = Longitude_WGS84_Decode((&(pVal->lon)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && Location_Fix_Packet_IsConstraintValid(pVal, pErrCode);
}

flag Location_Fix_Packet_ACN_Encode(const Location_Fix_Packet* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Location_Fix_Packet_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode t */
	    ret = Time_UNIX_ACN_Encode((&(pVal->t)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode lat */
	        ret = Latitude_WGS84_ACN_Encode((&(pVal->lat)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode lon */
	            ret = Longitude_WGS84_ACN_Encode((&(pVal->lon)), pBitStrm, pErrCode, FALSE);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Location_Fix_Packet_ACN_Decode(Location_Fix_Packet* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode t */
	ret = Time_UNIX_ACN_Decode((&(pVal->t)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode lat */
	    ret = Latitude_WGS84_ACN_Decode((&(pVal->lat)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode lon */
	        ret = Longitude_WGS84_ACN_Decode((&(pVal->lon)), pBitStrm, pErrCode);
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && Location_Fix_Packet_IsConstraintValid(pVal, pErrCode);
}



flag Temperature_Generic_Equal(const Temperature_Generic* pVal1, const Temperature_Generic* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Temperature_Generic_IsConstraintValid(const Temperature_Generic* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2.0000000000000000000E+002 <= (*(pVal))) && ((*(pVal)) <= 2.0000000000000000000E+002));
    *pErrCode = ret ? 0 :  ERR_TEMPERATURE_GENERIC; 

	return ret;
}

void Temperature_Generic_Initialize(Temperature_Generic* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag Temperature_Generic_Encode(const Temperature_Generic* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Temperature_Generic_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Temperature_Generic_Decode(Temperature_Generic* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TEMPERATURE_GENERIC;

	return ret  && Temperature_Generic_IsConstraintValid(pVal, pErrCode);
}

flag Temperature_Generic_ACN_Encode(const Temperature_Generic* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Temperature_Generic_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Temperature_Generic_ACN_Decode(Temperature_Generic* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_TEMPERATURE_GENERIC;

    return ret && Temperature_Generic_IsConstraintValid(pVal, pErrCode);
}



flag Deployment_Digital_Equal(const Deployment_Digital* pVal1, const Deployment_Digital* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Deployment_Digital_IsConstraintValid(const Deployment_Digital* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void Deployment_Digital_Initialize(Deployment_Digital* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag Deployment_Digital_Encode(const Deployment_Digital* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Deployment_Digital_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Deployment_Digital_Decode(Deployment_Digital* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_DEPLOYMENT_DIGITAL;

	return ret  && Deployment_Digital_IsConstraintValid(pVal, pErrCode);
}

flag Deployment_Digital_ACN_Encode(const Deployment_Digital* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Deployment_Digital_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Deployment_Digital_ACN_Decode(Deployment_Digital* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DEPLOYMENT_DIGITAL;

    return ret && Deployment_Digital_IsConstraintValid(pVal, pErrCode);
}



flag Deployment_Analogue_Equal(const Deployment_Analogue* pVal1, const Deployment_Analogue* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Deployment_Analogue_IsConstraintValid(const Deployment_Analogue* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((0.0000000000000000000E+000 <= (*(pVal))) && ((*(pVal)) <= 1.0000000000000000000E+002));
    *pErrCode = ret ? 0 :  ERR_DEPLOYMENT_ANALOGUE; 

	return ret;
}

void Deployment_Analogue_Initialize(Deployment_Analogue* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag Deployment_Analogue_Encode(const Deployment_Analogue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Deployment_Analogue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Deployment_Analogue_Decode(Deployment_Analogue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_DEPLOYMENT_ANALOGUE;

	return ret  && Deployment_Analogue_IsConstraintValid(pVal, pErrCode);
}

flag Deployment_Analogue_ACN_Encode(const Deployment_Analogue* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Deployment_Analogue_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Deployment_Analogue_ACN_Decode(Deployment_Analogue* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_DEPLOYMENT_ANALOGUE;

    return ret && Deployment_Analogue_IsConstraintValid(pVal, pErrCode);
}



flag System_Mode_Equal(const System_Mode* pVal1, const System_Mode* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag System_Mode_IsConstraintValid(const System_Mode* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((*(pVal)) == System_Mode_idle)) || (((*(pVal)) == System_Mode_uplink)))) || (((*(pVal)) == System_Mode_downlink)))) || (((*(pVal)) == System_Mode_imaging)))) || (((*(pVal)) == System_Mode_processing)));
    *pErrCode = ret ? 0 :  ERR_SYSTEM_MODE; 

	return ret;
}

void System_Mode_Initialize(System_Mode* pVal)
{
	(void)pVal;


	(*(pVal)) = System_Mode_idle;
}

flag System_Mode_Encode(const System_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? System_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case System_Mode_idle:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case System_Mode_uplink:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case System_Mode_downlink:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case System_Mode_imaging:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case System_Mode_processing:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SYSTEM_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag System_Mode_Decode(System_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SYSTEM_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = System_Mode_idle;
	                break;
	            case 1: 
	                (*(pVal)) = System_Mode_uplink;
	                break;
	            case 2: 
	                (*(pVal)) = System_Mode_downlink;
	                break;
	            case 3: 
	                (*(pVal)) = System_Mode_imaging;
	                break;
	            case 4: 
	                (*(pVal)) = System_Mode_processing;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SYSTEM_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = System_Mode_idle;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && System_Mode_IsConstraintValid(pVal, pErrCode);
}

flag System_Mode_ACN_Encode(const System_Mode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? System_Mode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case System_Mode_idle:
	            uIntVal = 0;
	            break;
	        case System_Mode_uplink:
	            uIntVal = 1;
	            break;
	        case System_Mode_downlink:
	            uIntVal = 2;
	            break;
	        case System_Mode_imaging:
	            uIntVal = 3;
	            break;
	        case System_Mode_processing:
	            uIntVal = 4;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SYSTEM_MODE;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 4);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag System_Mode_ACN_Decode(System_Mode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 4);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SYSTEM_MODE;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = System_Mode_idle;
	            break;
	        case 1:
	            (*(pVal)) = System_Mode_uplink;
	            break;
	        case 2:
	            (*(pVal)) = System_Mode_downlink;
	            break;
	        case 3:
	            (*(pVal)) = System_Mode_imaging;
	            break;
	        case 4:
	            (*(pVal)) = System_Mode_processing;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SYSTEM_MODE;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && System_Mode_IsConstraintValid(pVal, pErrCode);
}



flag Subsystem_Address_Equal(const Subsystem_Address* pVal1, const Subsystem_Address* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Subsystem_Address_IsConstraintValid(const Subsystem_Address* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == Subsystem_Address_obc)) || (((*(pVal)) == Subsystem_Address_comms)))) || (((*(pVal)) == Subsystem_Address_electrical)))) || (((*(pVal)) == Subsystem_Address_mechanical)))) || (((*(pVal)) == Subsystem_Address_control)))) || (((*(pVal)) == Subsystem_Address_software)))) || (((*(pVal)) == Subsystem_Address_payload)));
    *pErrCode = ret ? 0 :  ERR_SUBSYSTEM_ADDRESS; 

	return ret;
}

void Subsystem_Address_Initialize(Subsystem_Address* pVal)
{
	(void)pVal;


	(*(pVal)) = Subsystem_Address_obc;
}

flag Subsystem_Address_Encode(const Subsystem_Address* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Subsystem_Address_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case Subsystem_Address_obc:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case Subsystem_Address_comms:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case Subsystem_Address_electrical:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case Subsystem_Address_mechanical:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case Subsystem_Address_control:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case Subsystem_Address_software:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case Subsystem_Address_payload:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SUBSYSTEM_ADDRESS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Subsystem_Address_Decode(Subsystem_Address* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SUBSYSTEM_ADDRESS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = Subsystem_Address_obc;
	                break;
	            case 1: 
	                (*(pVal)) = Subsystem_Address_comms;
	                break;
	            case 2: 
	                (*(pVal)) = Subsystem_Address_electrical;
	                break;
	            case 3: 
	                (*(pVal)) = Subsystem_Address_mechanical;
	                break;
	            case 4: 
	                (*(pVal)) = Subsystem_Address_control;
	                break;
	            case 5: 
	                (*(pVal)) = Subsystem_Address_software;
	                break;
	            case 6: 
	                (*(pVal)) = Subsystem_Address_payload;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SUBSYSTEM_ADDRESS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = Subsystem_Address_obc;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Subsystem_Address_IsConstraintValid(pVal, pErrCode);
}

flag Subsystem_Address_ACN_Encode(const Subsystem_Address* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? Subsystem_Address_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case Subsystem_Address_obc:
	            uIntVal = 0;
	            break;
	        case Subsystem_Address_comms:
	            uIntVal = 1;
	            break;
	        case Subsystem_Address_electrical:
	            uIntVal = 2;
	            break;
	        case Subsystem_Address_mechanical:
	            uIntVal = 3;
	            break;
	        case Subsystem_Address_control:
	            uIntVal = 4;
	            break;
	        case Subsystem_Address_software:
	            uIntVal = 5;
	            break;
	        case Subsystem_Address_payload:
	            uIntVal = 6;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_SUBSYSTEM_ADDRESS;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 6);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Subsystem_Address_ACN_Decode(Subsystem_Address* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_SUBSYSTEM_ADDRESS;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = Subsystem_Address_obc;
	            break;
	        case 1:
	            (*(pVal)) = Subsystem_Address_comms;
	            break;
	        case 2:
	            (*(pVal)) = Subsystem_Address_electrical;
	            break;
	        case 3:
	            (*(pVal)) = Subsystem_Address_mechanical;
	            break;
	        case 4:
	            (*(pVal)) = Subsystem_Address_control;
	            break;
	        case 5:
	            (*(pVal)) = Subsystem_Address_software;
	            break;
	        case 6:
	            (*(pVal)) = Subsystem_Address_payload;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_SUBSYSTEM_ADDRESS;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && Subsystem_Address_IsConstraintValid(pVal, pErrCode);
}



flag Mode_Change_Packet_ttl_ms_Equal(const Mode_Change_Packet_ttl_ms* pVal1, const Mode_Change_Packet_ttl_ms* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag Mode_Change_Packet_Equal(const Mode_Change_Packet* pVal1, const Mode_Change_Packet* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->target_addr == pVal2->target_addr);

    if (ret) {
        ret = (pVal1->target_mode == pVal2->target_mode);

        if (ret) {
            ret = Mode_Change_Packet_ttl_ms_Equal((&(pVal1->ttl_ms)), (&(pVal2->ttl_ms)));

        }

    }

	return ret;

}

flag Mode_Change_Packet_ttl_ms_IsConstraintValid(const Mode_Change_Packet_ttl_ms* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 10000UL);
    *pErrCode = ret ? 0 :  ERR_MODE_CHANGE_PACKET_TTL_MS; 

	return ret;
}

flag Mode_Change_Packet_IsConstraintValid(const Mode_Change_Packet* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = Subsystem_Address_IsConstraintValid((&(pVal->target_addr)), pErrCode);
    if (ret) {
        ret = System_Mode_IsConstraintValid((&(pVal->target_mode)), pErrCode);
        if (ret) {
            ret = Mode_Change_Packet_ttl_ms_IsConstraintValid((&(pVal->ttl_ms)), pErrCode);
        }   /*COVERAGE_IGNORE*/
    }   /*COVERAGE_IGNORE*/

	return ret;
}

void Mode_Change_Packet_ttl_ms_Initialize(Mode_Change_Packet_ttl_ms* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}
void Mode_Change_Packet_Initialize(Mode_Change_Packet* pVal)
{
	(void)pVal;



	/*set target_addr */
	Subsystem_Address_Initialize((&(pVal->target_addr)));
	/*set target_mode */
	System_Mode_Initialize((&(pVal->target_mode)));
	/*set ttl_ms */
	Mode_Change_Packet_ttl_ms_Initialize((&(pVal->ttl_ms)));
}

flag Mode_Change_Packet_Encode(const Mode_Change_Packet* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? Mode_Change_Packet_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode target_addr */
	    ret = Subsystem_Address_Encode((&(pVal->target_addr)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode target_mode */
	        ret = System_Mode_Encode((&(pVal->target_mode)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ttl_ms */
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->ttl_ms, 0, 10000);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Mode_Change_Packet_Decode(Mode_Change_Packet* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode target_addr */
	ret = Subsystem_Address_Decode((&(pVal->target_addr)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode target_mode */
	    ret = System_Mode_Decode((&(pVal->target_mode)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ttl_ms */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->ttl_ms)), 0, 10000);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_MODE_CHANGE_PACKET_TTL_MS;
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

	return ret  && Mode_Change_Packet_IsConstraintValid(pVal, pErrCode);
}

flag Mode_Change_Packet_ACN_Encode(const Mode_Change_Packet* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? Mode_Change_Packet_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode target_addr */
	    ret = Subsystem_Address_ACN_Encode((&(pVal->target_addr)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode target_mode */
	        ret = System_Mode_ACN_Encode((&(pVal->target_mode)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode ttl_ms */
	            BitStream_EncodeConstraintPosWholeNumber(pBitStrm, pVal->ttl_ms, 0, 10000);
	        }   /*COVERAGE_IGNORE*/
	    }   /*COVERAGE_IGNORE*/
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Mode_Change_Packet_ACN_Decode(Mode_Change_Packet* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode target_addr */
	ret = Subsystem_Address_ACN_Decode((&(pVal->target_addr)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode target_mode */
	    ret = System_Mode_ACN_Decode((&(pVal->target_mode)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode ttl_ms */
	        ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(pVal->ttl_ms)), 0, 10000);
	        *pErrCode = ret ? 0 : ERR_ACN_DECODE_MODE_CHANGE_PACKET_TTL_MS;
	    }   /*COVERAGE_IGNORE*/
	}   /*COVERAGE_IGNORE*/

    return ret && Mode_Change_Packet_IsConstraintValid(pVal, pErrCode);
}



flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

void T_Int32_Initialize(T_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && T_Int32_IsConstraintValid(pVal, pErrCode);
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT32;

    return ret && T_Int32_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

void T_UInt32_Initialize(T_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && T_UInt32_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT32;

    return ret && T_UInt32_IsConstraintValid(pVal, pErrCode);
}



flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

void T_Int8_Initialize(T_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && T_Int8_IsConstraintValid(pVal, pErrCode);
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_INT8;

    return ret && T_Int8_IsConstraintValid(pVal, pErrCode);
}



flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

void T_UInt8_Initialize(T_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && T_UInt8_IsConstraintValid(pVal, pErrCode);
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_UINT8;

    return ret && T_UInt8_IsConstraintValid(pVal, pErrCode);
}



flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Boolean_Initialize(T_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && T_Boolean_IsConstraintValid(pVal, pErrCode);
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_T_BOOLEAN;

    return ret && T_Boolean_IsConstraintValid(pVal, pErrCode);
}



flag T_Null_Record_Equal(const T_Null_Record* pVal1, const T_Null_Record* pVal2)
{
	(void)pVal1;
	(void)pVal2;
	return TRUE;

}

flag T_Null_Record_IsConstraintValid(const T_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

void T_Null_Record_Initialize(T_Null_Record* pVal)
{
	(void)pVal;


}

flag T_Null_Record_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}

flag T_Null_Record_ACN_Encode(const T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;

    *pErrCode = 0;
	ret = bCheckConstraints ? T_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Null_Record_ACN_Decode(T_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	(void)pBitStrm;
	*pErrCode = 0;



    return ret && T_Null_Record_IsConstraintValid(pVal, pErrCode);
}



flag PID_Equal(const PID* pVal1, const PID* pVal2)
{
	return (*(pVal1)) == (*(pVal2));

}

flag PID_IsConstraintValid(const PID* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((((((((((((((*(pVal)) == PID_loc_provider)) || (((*(pVal)) == PID_state_handler_entrypoint)))) || (((*(pVal)) == PID_tc_provider)))) || (((*(pVal)) == PID_tc_validation)))) || (((*(pVal)) == PID_tm_collection)))) || (((*(pVal)) == PID_tm_provider)))) || (((*(pVal)) == PID_env)));
    *pErrCode = ret ? 0 :  ERR_PID; 

	return ret;
}

void PID_Initialize(PID* pVal)
{
	(void)pVal;


	(*(pVal)) = PID_loc_provider;
}

flag PID_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) 
	    {
	        case PID_loc_provider:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case PID_state_handler_entrypoint:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case PID_tc_provider:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case PID_tc_validation:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case PID_tm_collection:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case PID_tm_provider:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case PID_env:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_PID; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_PID;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = PID_loc_provider;
	                break;
	            case 1: 
	                (*(pVal)) = PID_state_handler_entrypoint;
	                break;
	            case 2: 
	                (*(pVal)) = PID_tc_provider;
	                break;
	            case 3: 
	                (*(pVal)) = PID_tc_validation;
	                break;
	            case 4: 
	                (*(pVal)) = PID_tm_collection;
	                break;
	            case 5: 
	                (*(pVal)) = PID_tm_provider;
	                break;
	            case 6: 
	                (*(pVal)) = PID_env;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_PID;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = PID_loc_provider;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && PID_IsConstraintValid(pVal, pErrCode);
}

flag PID_ACN_Encode(const PID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

	asn1SccUint uIntVal;
    *pErrCode = 0;
	ret = bCheckConstraints ? PID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    switch((*(pVal))) { 
	        case PID_loc_provider:
	            uIntVal = 0;
	            break;
	        case PID_state_handler_entrypoint:
	            uIntVal = 1;
	            break;
	        case PID_tc_provider:
	            uIntVal = 2;
	            break;
	        case PID_tc_validation:
	            uIntVal = 3;
	            break;
	        case PID_tm_collection:
	            uIntVal = 4;
	            break;
	        case PID_tm_provider:
	            uIntVal = 5;
	            break;
	        case PID_env:
	            uIntVal = 6;
	            break;
	        default:                                    /*COVERAGE_IGNORE*/
	            ret = FALSE;                            /*COVERAGE_IGNORE*/
	            *pErrCode = ERR_ACN_ENCODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	    if (ret) {
	    	BitStream_EncodeConstraintPosWholeNumber(pBitStrm, uIntVal, 0, 6);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag PID_ACN_Decode(PID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	asn1SccUint uIntVal;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, (&(uIntVal)), 0, 6);
	*pErrCode = ret ? 0 : ERR_ACN_DECODE_PID;
	if (ret) {
	    switch (uIntVal) {
	        case 0:
	            (*(pVal)) = PID_loc_provider;
	            break;
	        case 1:
	            (*(pVal)) = PID_state_handler_entrypoint;
	            break;
	        case 2:
	            (*(pVal)) = PID_tc_provider;
	            break;
	        case 3:
	            (*(pVal)) = PID_tc_validation;
	            break;
	        case 4:
	            (*(pVal)) = PID_tm_collection;
	            break;
	        case 5:
	            (*(pVal)) = PID_tm_provider;
	            break;
	        case 6:
	            (*(pVal)) = PID_env;
	            break;
	    default:                                    /*COVERAGE_IGNORE*/
	        ret = FALSE;                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_ACN_DECODE_PID;                 /*COVERAGE_IGNORE*/
	    }
	} /*COVERAGE_IGNORE*/

    return ret && PID_IsConstraintValid(pVal, pErrCode);
}

