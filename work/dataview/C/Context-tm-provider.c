/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"
#include "asn1crt_encoding_acn.h"

#include "Context-tm-provider.h"


const asn1SccContext_tm_provider tm_provider_ctxt = {
    .k = 0
};


flag asn1SccContext_tm_provider_Equal(const asn1SccContext_tm_provider* pVal1, const asn1SccContext_tm_provider* pVal2)
{
	flag ret=TRUE;

    ret = (pVal1->k == pVal2->k);

	return ret;

}

flag asn1SccContext_tm_provider_IsConstraintValid(const asn1SccContext_tm_provider* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = asn1SccCounterK_IsConstraintValid((&(pVal->k)), pErrCode);

	return ret;
}

void asn1SccContext_tm_provider_Initialize(asn1SccContext_tm_provider* pVal)
{
	(void)pVal;



	/*set k */
	asn1SccCounterK_Initialize((&(pVal->k)));
}

flag asn1SccContext_tm_provider_Encode(const asn1SccContext_tm_provider* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccContext_tm_provider_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode k */
	    ret = asn1SccCounterK_Encode((&(pVal->k)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccContext_tm_provider_Decode(asn1SccContext_tm_provider* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode k */
	ret = asn1SccCounterK_Decode((&(pVal->k)), pBitStrm, pErrCode);

	return ret  && asn1SccContext_tm_provider_IsConstraintValid(pVal, pErrCode);
}

flag asn1SccContext_tm_provider_ACN_Encode(const asn1SccContext_tm_provider* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    *pErrCode = 0;
	ret = bCheckConstraints ? asn1SccContext_tm_provider_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    /*Encode k */
	    ret = asn1SccCounterK_ACN_Encode((&(pVal->k)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccContext_tm_provider_ACN_Decode(asn1SccContext_tm_provider* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	/*Decode k */
	ret = asn1SccCounterK_ACN_Decode((&(pVal->k)), pBitStrm, pErrCode);

    return ret && asn1SccContext_tm_provider_IsConstraintValid(pVal, pErrCode);
}

